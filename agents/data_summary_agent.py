#!/usr/bin/env python3
"""Data Summary Agent (Gemini Flash Lite + local heuristics)

This agent:
- Interprets the JSON output from pose_extraction_shooting_drills.py
- Produces a short, data-focused summary using deterministic heuristics
- Optionally sends the draft to a lightweight LLM (Gemini 2.5 Flash Lite)
  for tone polishing, with strict instructions and low token limits

Usage:
  python data_summary_agent.py results/drill/foo_drill_feedback.json

Environment:
  GOOGLE_API_KEY (optional). If missing or model fails, falls back to local summary.
"""

from __future__ import annotations

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from utils.config import load_env
from utils.io import load_json_file
load_env()

# Unified Google GenAI client import
try:
    from google import genai  # type: ignore
    GENAI_AVAILABLE = True
except Exception:
    GENAI_AVAILABLE = False



def load_feedback_json(json_path: Path) -> Dict[str, Any]:
    """Load a drill feedback JSON file using shared utility.

    Args:
        json_path: Path to the JSON file generated by pose_extraction_shooting_drills.py

    Returns:
        Parsed JSON as a Python dict.
    """
    return load_json_file(json_path)


def format_timestamp(time_sec: float) -> str:
    """Format time in seconds to MM:SS format.
    
    Args:
        time_sec: Time in seconds (can have decimal places)
        
    Returns:
        Formatted time string in MM:SS format
    """
    if time_sec == "N/A" or time_sec is None:
        return "N/A"
    
    try:
        total_seconds = int(round(float(time_sec)))
        minutes = total_seconds // 60
        seconds = total_seconds % 60
        return f"{minutes:02d}:{seconds:02d}"
    except (ValueError, TypeError):
        return "N/A"


def score_front_knee_bend(angle_deg: float) -> Tuple[int, str]:
    """Score front knee bend on 1-10 scale for high school/college level.
    
    Args:
        angle_deg: Knee bend angle in degrees
        
    Returns:
        Tuple of (score 1-10, category)
    """
    # Adjusted for high school/college level expectations
    if angle_deg <= 110:
        return (10, "excellent")
    elif angle_deg <= 120:
        return (9, "very good")
    elif angle_deg <= 130:
        return (8, "good")
    elif angle_deg <= 140:
        return (7, "fair")
    elif angle_deg <= 150:
        return (6, "poor")
    elif angle_deg <= 160:
        return (4, "very poor")
    else:
        return (2, "terrible")

def score_hip_rotation_power(rotation_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score hip rotation power on 1-10 scale.
    
    Args:
        rotation_data: hip_rotation_power dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    max_speed = rotation_data.get("max_rotation_speed", 0.0)
    angle_change = rotation_data.get("rotation_angle_change", 0.0)
    
    # Combine speed and angle change for overall power score
    power_score = (max_speed * 0.6) + (angle_change * 0.4)
    
    if power_score >= 60:
        return (10, "explosive")
    elif power_score >= 45:
        return (9, "excellent")
    elif power_score >= 35:
        return (8, "very good")
    elif power_score >= 25:
        return (7, "good")
    elif power_score >= 15:
        return (6, "fair")
    elif power_score >= 10:
        return (5, "poor")
    elif power_score >= 5:
        return (3, "very poor")
    else:
        return (1, "none")

def score_weight_transfer(transfer_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score weight transfer on 1-10 scale.
    
    Args:
        transfer_data: weight_transfer dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    max_speed = transfer_data.get("max_transfer_speed", 0.0)
    distance = transfer_data.get("weight_shift_distance", 0.0)
    
    # Combine speed and distance for transfer quality
    transfer_score = (max_speed * 1000) + (distance * 1000)  # Scale up small values
    
    if transfer_score >= 0.05:
        return (10, "excellent")
    elif transfer_score >= 0.03:
        return (9, "very good")
    elif transfer_score >= 0.02:
        return (8, "good")
    elif transfer_score >= 0.015:
        return (7, "fair")
    elif transfer_score >= 0.01:
        return (6, "poor")
    elif transfer_score >= 0.005:
        return (4, "very poor")
    else:
        return (2, "minimal")

def score_torso_rotation(rotation_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score torso rotation on 1-10 scale.
    
    Args:
        rotation_data: torso_rotation dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    shoulder_rot = rotation_data.get("shoulder_rotation", 0.0)
    hip_rot = rotation_data.get("hip_rotation", 0.0)
    sync = rotation_data.get("rotation_sync", 0.0)
    
    # Score based on rotation amount and synchronization
    rotation_amount = max(shoulder_rot, hip_rot)
    sync_bonus = sync * 2  # Sync is 0-1, so multiply by 2 for bonus
    
    total_score = rotation_amount + sync_bonus
    
    if total_score >= 50:
        return (10, "excellent")
    elif total_score >= 40:
        return (9, "very good")
    elif total_score >= 30:
        return (8, "good")
    elif total_score >= 20:
        return (7, "fair")
    elif total_score >= 15:
        return (6, "poor")
    elif total_score >= 10:
        return (4, "very poor")
    else:
        return (2, "minimal")

def score_back_leg_drive(drive_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score back leg drive on 1-10 scale.
    
    Args:
        drive_data: back_leg_drive dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    extension_change = drive_data.get("extension_change", 0.0)
    extension_speed = drive_data.get("extension_speed", 0.0)
    consistency = drive_data.get("drive_consistency", 0.0)
    
    # Combine extension change, speed, and consistency
    drive_score = (extension_change * 0.4) + (extension_speed * 0.4) + (consistency * 20)
    
    if drive_score >= 25:
        return (10, "excellent")
    elif drive_score >= 20:
        return (9, "very good")
    elif drive_score >= 15:
        return (8, "good")
    elif drive_score >= 10:
        return (7, "fair")
    elif drive_score >= 7:
        return (6, "poor")
    elif drive_score >= 4:
        return (4, "very poor")
    else:
        return (2, "minimal")

def score_wrist_extension(extension_data: Dict[str, Any]) -> Tuple[int, str, Dict[str, Any]]:
    """Score wrist extension on 1-10 scale, showing left and right separately.
    
    Args:
        extension_data: wrist_extension dict from shot
        
    Returns:
        Tuple of (overall_score, category, wrist_breakdown)
    """
    follow_through = extension_data.get("follow_through_score")
    left_score = extension_data.get("left_wrist_extension_score")
    right_score = extension_data.get("right_wrist_extension_score")
    
    # Score each wrist individually
    left_wrist_score = 0
    right_wrist_score = 0
    left_tracked = False
    right_tracked = False
    
    # Score left wrist
    if left_score is not None and left_score > 30:
        left_wrist_score = _score_wrist_individual(left_score)
        left_tracked = True
    
    # Score right wrist  
    if right_score is not None and right_score > 30:
        right_wrist_score = _score_wrist_individual(right_score)
        right_tracked = True
    
    # Use follow-through as backup if available
    if follow_through is not None and follow_through > 30 and not left_tracked and not right_tracked:
        overall_score = _score_wrist_individual(follow_through)
        category = _get_wrist_category(overall_score)
        return (overall_score, category, {
            "left_wrist": {"score": 0, "tracked": False},
            "right_wrist": {"score": 0, "tracked": False},
            "follow_through": {"score": overall_score, "tracked": True}
        })
    
    # If no valid data, mark as not tracked
    if not left_tracked and not right_tracked:
        return (0, "not tracked", {
            "left_wrist": {"score": 0, "tracked": False},
            "right_wrist": {"score": 0, "tracked": False},
            "follow_through": {"score": 0, "tracked": False}
        })
    
    # Calculate overall score as average of tracked wrists
    if left_tracked and right_tracked:
        overall_score = (left_wrist_score + right_wrist_score) / 2
    elif left_tracked:
        overall_score = left_wrist_score
    else:
        overall_score = right_wrist_score
    
    category = _get_wrist_category(overall_score)
    
    return (overall_score, category, {
        "left_wrist": {"score": left_wrist_score, "tracked": left_tracked},
        "right_wrist": {"score": right_wrist_score, "tracked": right_tracked},
        "follow_through": {"score": follow_through if follow_through and follow_through > 30 else 0, "tracked": follow_through and follow_through > 30}
    })

def _score_wrist_individual(score: float) -> int:
    """Score individual wrist extension."""
    if score >= 90:
        return 10
    elif score >= 80:
        return 9
    elif score >= 70:
        return 8
    elif score >= 60:
        return 7
    elif score >= 50:
        return 6
    elif score >= 40:
        return 4
    else:
        return 2

def _get_wrist_category(score: float) -> str:
    """Get wrist extension category."""
    if score >= 9:
        return "excellent"
    elif score >= 8:
        return "very good"
    elif score >= 7:
        return "good"
    elif score >= 6:
        return "fair"
    elif score >= 4:
        return "poor"
    else:
        return "minimal"

def score_head_position(head_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score head position on 1-10 scale.
    
    Args:
        head_data: head_position dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    head_up = head_data.get("head_up_score", 0.0)
    eyes_forward = head_data.get("eyes_forward_score", 0.0)
    
    # Check if we have valid data
    if head_up is None and eyes_forward is None:
        return (0, "not tracked")
    
    # Average head up and eyes forward scores, or use available data
    if head_up is not None and eyes_forward is not None:
        score = (head_up + eyes_forward) / 2
    elif head_up is not None:
        score = head_up
    else:
        score = eyes_forward
    
    # More lenient thresholds for head position
    if score >= 85:
        return (10, "excellent")
    elif score >= 75:
        return (9, "very good")
    elif score >= 65:
        return (8, "good")
    elif score >= 55:
        return (7, "fair")
    elif score >= 45:
        return (6, "poor")
    elif score >= 35:
        return (4, "very poor")
    else:
        return (2, "minimal")

def score_body_stability(stability_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score body stability on 1-10 scale.
    
    Args:
        stability_data: body_stability dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    stability_score = stability_data.get("stability_score", 0.0)
    consistency = stability_data.get("movement_consistency", 0.0)
    
    # Use stability score as primary, consistency as secondary
    score = (stability_score * 0.7) + (consistency * 0.3)
    
    if score >= 0.9:
        return (10, "excellent")
    elif score >= 0.8:
        return (9, "very good")
    elif score >= 0.7:
        return (8, "good")
    elif score >= 0.6:
        return (7, "fair")
    elif score >= 0.5:
        return (6, "poor")
    elif score >= 0.3:
        return (4, "very poor")
    else:
        return (2, "minimal")

def calculate_power_score(shot: Dict[str, Any]) -> Tuple[float, Dict[str, Any]]:
    """Calculate power score (70% weight) and individual power metrics.
    
    Args:
        shot: Shot data dictionary
        
    Returns:
        Tuple of (power_score, power_metrics_dict)
    """
    power_metrics = {}
    
    # Front Knee Bend (15% of total)
    front_knee_angle = shot.get("front_knee_bend_deg")
    if front_knee_angle is not None:
        knee_score, knee_category = score_front_knee_bend(front_knee_angle)
        power_metrics["front_knee"] = {
            "score": knee_score,
            "category": knee_category,
            "angle": front_knee_angle
        }
    else:
        power_metrics["front_knee"] = {"score": 1, "category": "not tracked", "angle": None}
    
    # Hip Rotation Power (15% of total)
    hip_rotation = shot.get("hip_rotation_power", {})
    if hip_rotation:
        hip_score, hip_category = score_hip_rotation_power(hip_rotation)
        power_metrics["hip_rotation"] = {
            "score": hip_score,
            "category": hip_category,
            "data": hip_rotation
        }
    else:
        power_metrics["hip_rotation"] = {"score": 1, "category": "not tracked", "data": {}}
    
    # Back Leg Drive (10% of total)
    back_leg_drive = shot.get("back_leg_drive", {})
    if back_leg_drive:
        drive_score, drive_category = score_back_leg_drive(back_leg_drive)
        power_metrics["back_leg_drive"] = {
            "score": drive_score,
            "category": drive_category,
            "data": back_leg_drive
        }
    else:
        power_metrics["back_leg_drive"] = {"score": 1, "category": "not tracked", "data": {}}
    
    # Weight Transfer (15% of total)
    weight_transfer = shot.get("weight_transfer", {})
    if weight_transfer:
        transfer_score, transfer_category = score_weight_transfer(weight_transfer)
        power_metrics["weight_transfer"] = {
            "score": transfer_score,
            "category": transfer_category,
            "data": weight_transfer
        }
    else:
        power_metrics["weight_transfer"] = {"score": 1, "category": "not tracked", "data": {}}
    
    # Torso Rotation (15% of total)
    torso_rotation = shot.get("torso_rotation", {})
    if torso_rotation:
        torso_score, torso_category = score_torso_rotation(torso_rotation)
        power_metrics["torso_rotation"] = {
            "score": torso_score,
            "category": torso_category,
            "data": torso_rotation
        }
    else:
        power_metrics["torso_rotation"] = {"score": 1, "category": "not tracked", "data": {}}
    
    # Calculate weighted power score
    power_score = (
        power_metrics["front_knee"]["score"] * 0.15 +
        power_metrics["hip_rotation"]["score"] * 0.15 +
        power_metrics["back_leg_drive"]["score"] * 0.10 +
        power_metrics["weight_transfer"]["score"] * 0.15 +
        power_metrics["torso_rotation"]["score"] * 0.15
    )
    
    return power_score, power_metrics

def calculate_form_score(shot: Dict[str, Any]) -> Tuple[float, Dict[str, Any]]:
    """Calculate form score (30% weight) and individual form metrics.
    
    Args:
        shot: Shot data dictionary
        
    Returns:
        Tuple of (form_score, form_metrics_dict)
    """
    form_metrics = {}
    tracked_metrics = []
    total_weight = 0.0
    
    # Wrist Extension (15% of total)
    wrist_extension = shot.get("wrist_extension", {})
    if wrist_extension:
        wrist_score, wrist_category, wrist_breakdown = score_wrist_extension(wrist_extension)
        form_metrics["wrist_extension"] = {
            "score": wrist_score,
            "category": wrist_category,
            "data": wrist_extension,
            "tracked": wrist_score > 0,
            "breakdown": wrist_breakdown
        }
        if wrist_score > 0:
            tracked_metrics.append(("wrist_extension", wrist_score, 0.15))
            total_weight += 0.15
    else:
        form_metrics["wrist_extension"] = {
            "score": 0, 
            "category": "not tracked", 
            "data": {}, 
            "tracked": False,
            "breakdown": {
                "left_wrist": {"score": 0, "tracked": False},
                "right_wrist": {"score": 0, "tracked": False},
                "follow_through": {"score": 0, "tracked": False}
            }
        }
    
    # Head Position (5% of total)
    head_position = shot.get("head_position", {})
    if head_position:
        head_score, head_category = score_head_position(head_position)
        form_metrics["head_position"] = {
            "score": head_score,
            "category": head_category,
            "data": head_position,
            "tracked": head_score > 0
        }
        if head_score > 0:
            tracked_metrics.append(("head_position", head_score, 0.05))
            total_weight += 0.05
    else:
        form_metrics["head_position"] = {"score": 0, "category": "not tracked", "data": {}, "tracked": False}
    
    # Body Stability (10% of total)
    body_stability = shot.get("body_stability", {})
    if body_stability:
        stability_score, stability_category = score_body_stability(body_stability)
        form_metrics["body_stability"] = {
            "score": stability_score,
            "category": stability_category,
            "data": body_stability,
            "tracked": stability_score > 0
        }
        if stability_score > 0:
            tracked_metrics.append(("body_stability", stability_score, 0.10))
            total_weight += 0.10
    else:
        form_metrics["body_stability"] = {"score": 0, "category": "not tracked", "data": {}, "tracked": False}
    
    # Calculate weighted form score only from tracked metrics
    if tracked_metrics and total_weight > 0:
        # Normalize weights to sum to 1.0 for tracked metrics only
        form_score = sum(score * (weight / total_weight) for _, score, weight in tracked_metrics)
        # Scale back to original 30% of total
        form_score = form_score * total_weight
    else:
        form_score = 0.0
    
    return form_score, form_metrics

def apply_age_adjustment(score: float, age_group: str) -> float:
    """Apply age-based scoring adjustment based on predefined age groups.
    
    Args:
        score: Raw score (1-10)
        age_group: Age group from app ("7-9", "10-12", "13-16", "17+")
        
    Returns:
        Adjusted score based on age group
    """
    if age_group == "17+":
        # 17+ years: Score as-is (high school/college level) - no curve
        return score
    elif age_group == "13-16":
        # 13-16 years: Slight curve (10% boost)
        return min(10.0, score * 1.1)
    elif age_group == "10-12":
        # 10-12 years: Moderate curve (20% boost)
        return min(10.0, score * 1.2)
    elif age_group == "7-9":
        # 7-9 years: Strong curve (30% boost)
        return min(10.0, score * 1.3)
    else:
        # Default to 17+ if unknown age group
        return score

def get_age_category(age_group: str) -> str:
    """Get age category description.
    
    Args:
        age_group: Age group from app ("7-9", "10-12", "13-16", "17+")
        
    Returns:
        Age category string
    """
    if age_group == "17+":
        return "High School/College (17+)"
    elif age_group == "13-16":
        return "U16 (13-16 years)"
    elif age_group == "10-12":
        return "U12 (10-12 years)"
    elif age_group == "7-9":
        return "U10 (7-9 years)"
    else:
        return "Unknown Age Group"

def validate_shot_data(shot: Dict[str, Any]) -> Dict[str, Any]:
    """Validate shot data and extract all relevant metrics with new scoring system.

    Args:
        shot: One shot dict from the feedback JSON

    Returns:
        A dict with validated fields, N/A for missing data.
    """
    result = {}
    
    # Basic timing and metrics
    result["time"] = shot.get("shot_time_sec", "N/A")
    result["time_formatted"] = format_timestamp(result["time"])
    
    # Get age group for adjustments (default to "17+" if not provided)
    age_group = shot.get("age_group", "17+")
    result["age_group"] = age_group
    result["age_category"] = get_age_category(age_group)
    
    # Calculate raw power and form scores
    raw_power_score, power_metrics = calculate_power_score(shot)
    raw_form_score, form_metrics = calculate_form_score(shot)
    
    # Apply age adjustments
    adjusted_power_score = apply_age_adjustment(raw_power_score, age_group)
    adjusted_form_score = apply_age_adjustment(raw_form_score, age_group)
    
    # Overall score (70% power + 30% form) with age adjustment
    overall_score = (adjusted_power_score * 0.70) + (adjusted_form_score * 0.30)
    
    # Apply minimum score floor (1.0/10) to prevent discouraging scores
    overall_score = max(overall_score, 1.0)
    adjusted_power_score = max(adjusted_power_score, 1.0)
    adjusted_form_score = max(adjusted_form_score, 1.0)
    
    # Store scores (both raw and adjusted)
    result["overall_score"] = round(overall_score, 1)
    result["power_score"] = round(adjusted_power_score, 1)
    result["form_score"] = round(adjusted_form_score, 1)
    result["raw_power_score"] = round(raw_power_score, 1)
    result["raw_form_score"] = round(raw_form_score, 1)
    result["power_metrics"] = power_metrics
    result["form_metrics"] = form_metrics
    
    # Legacy compatibility - keep some old fields
    result["front_knee_angle"] = f"{power_metrics['front_knee']['angle']:.0f}°" if power_metrics['front_knee']['angle'] is not None else "not tracked"
    result["hip_drive"] = f"{power_metrics['hip_rotation']['category']} ({power_metrics['hip_rotation']['score']}/10)"
    result["wrist_performance"] = f"{form_metrics['wrist_extension']['category']} ({form_metrics['wrist_extension']['score']}/10)"
    result["head_position"] = f"{form_metrics['head_position']['category']} ({form_metrics['head_position']['score']}/10)"
    result["body_stability"] = f"{form_metrics['body_stability']['category']} ({form_metrics['body_stability']['score']}/10)"
    
    return result


def format_shot_summary_locally(raw: Dict[str, Any]) -> str:
    """Generate formatted summary using local processing with new power vs form structure.
    
    Args:
        raw: Full analysis result dictionary
        
    Returns:
        Formatted summary string in the new structured format
    """
    shots = raw.get("shots", [])
    if not shots:
        return "No shots detected in video"
    
    # Format timestamp header
    timestamps = []
    for shot in shots:
        time_sec = shot.get("shot_time_sec")
        if time_sec is not None:
            timestamps.append(format_timestamp(time_sec))
        else:
            timestamps.append("N/A")
    
    timestamp_line = f"**Shots detected at timestamps:** {', '.join(timestamps)}"
    
    # Format each shot with new power vs form structure
    shot_lines = []
    for i, shot in enumerate(shots, 1):
        validated = validate_shot_data(shot)
        
        shot_block = f"**Shot {i}: {validated['time_formatted']}:**\n"
        shot_block += f"**Age Group:** {validated['age_category']}\n\n"
        
        # Raw Performance (no age adjustments)
        shot_block += f"**RAW PERFORMANCE:**\n"
        shot_block += f"Power: {validated['raw_power_score']}/10, Form: {validated['raw_form_score']}/10\n\n"
        
        # Coaching Score (age-adjusted)
        shot_block += f"**COACHING SCORE ({validated['age_category']} adjusted):**\n"
        shot_block += f"Power: {validated['power_score']}/10, Form: {validated['form_score']}/10\n"
        shot_block += f"Overall: {validated['overall_score']}/10\n\n"
        
        # Power Metrics Breakdown
        shot_block += f"**POWER BREAKDOWN:**\n"
        power_metrics = validated['power_metrics']
        
        # Front Knee Bend (15%)
        knee = power_metrics['front_knee']
        shot_block += f"├── Front Knee: {knee['score']}/10 ({knee['category']}, {knee['angle']:.0f}°)\n"
        
        # Hip Rotation Power (15%)
        hip = power_metrics['hip_rotation']
        shot_block += f"├── Hip Rotation: {hip['score']}/10 ({hip['category']})\n"
        
        # Back Leg Drive (10%)
        drive = power_metrics['back_leg_drive']
        shot_block += f"├── Back Leg Drive: {drive['score']}/10 ({drive['category']})\n"
        
        # Weight Transfer (15%)
        transfer = power_metrics['weight_transfer']
        shot_block += f"├── Weight Transfer: {transfer['score']}/10 ({transfer['category']})\n"
        
        # Torso Rotation (15%)
        torso = power_metrics['torso_rotation']
        shot_block += f"└── Torso Rotation: {torso['score']}/10 ({torso['category']})\n\n"
        
        # Form Metrics Breakdown
        shot_block += f"**FORM BREAKDOWN:**\n"
        form_metrics = validated['form_metrics']
        
        # Wrist Extension
        wrist = form_metrics['wrist_extension']
        if wrist['tracked']:
            breakdown = wrist['breakdown']
            left_info = f"L:{breakdown['left_wrist']['score']}/10" if breakdown['left_wrist']['tracked'] else "L:not tracked"
            right_info = f"R:{breakdown['right_wrist']['score']}/10" if breakdown['right_wrist']['tracked'] else "R:not tracked"
            follow_info = f"Follow:{breakdown['follow_through']['score']}/10" if breakdown['follow_through']['tracked'] else ""
            
            wrist_details = f"{left_info}, {right_info}"
            if follow_info:
                wrist_details += f", {follow_info}"
            
            shot_block += f"├── Wrist Extension: {wrist['score']}/10 ({wrist['category']}) - {wrist_details}\n"
        else:
            shot_block += f"├── Wrist Extension: Not tracked (insufficient data)\n"
        
        # Head Position
        head = form_metrics['head_position']
        if head['tracked']:
            shot_block += f"├── Head Position: {head['score']}/10 ({head['category']})\n"
        else:
            shot_block += f"├── Head Position: Not tracked (insufficient data)\n"
        
        # Body Stability
        stability = form_metrics['body_stability']
        if stability['tracked']:
            shot_block += f"└── Body Stability: {stability['score']}/10 ({stability['category']})"
        else:
            shot_block += f"└── Body Stability: Not tracked (insufficient data)"
        
        shot_lines.append(shot_block)
    
    return timestamp_line + "\n\n" + "\n\n".join(shot_lines)


def generate_summary_with_gemini(
    raw: Dict[str, Any],
    model_name: str = "gemini-2.5-flash-lite",
    temperature: float = 0.1,
    max_output_tokens: int = 1024,
) -> str:
    """Generate data-focused summary using Gemini with strict instructions.

    Returns polished text, or raises an error if fails.
    """
    if not GENAI_AVAILABLE:
        raise RuntimeError("google genai client not available. Install with: pip install google-genai")

    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        raise RuntimeError("GOOGLE_API_KEY environment variable not set")

    try:
        client = genai.Client(api_key=api_key)
        system = (
            "You are a data analysis system. Format the shooting drill JSON data into the EXACT structured format specified below. "
            "CRITICAL: Follow the format precisely with no deviations.\n\n"
            
            "Time formatting: Convert all shot_time_sec values to MM:SS format (e.g., 8.2 seconds becomes 00:08).\n"
            
            "Metrics interpretation:\n"
            "- Head position: Break down head_up_score and eyes_forward_score separately with intuitive labels\n"
            "- Wrist performance: Prefer wrist_extension.follow_through_score over setup_control (more reliable)\n"
            "- Hip drive: Include hip_drive_analysis.peak_forward_speed for context alongside category\n"
            "- Front knee angle: Use front_knee_bend_deg from lower_body_triangle if available, else knee_bend_min_deg\n"
            "- Back leg angle: Use back_leg_extension_deg from lower_body_triangle, add '(too bent)' if <150°\n"
            "- For any missing data, use 'not tracked'\n\n"
            
            "EXACT OUTPUT FORMAT:\n"
            "**Shots detected at timestamps:** MM:SS, MM:SS, MM:SS\n\n"
            "**Shot 1: MM:SS:**\n"
            "**head position:** head excellent/good/low (XX), eyes locked/focused/wandering (XX)\n"
            "**wrist performance:** excellent/good/fair extension (XX/100) or excellent/good/fair extension (XX/100, L:XX R:XX)\n"
            "**hip drive:** excellent/good/weak (XX/100, XX.X speed)\n"
            "**front knee angle:** XXX°\n"
            "**back leg angle:** XXX°\n\n"
            "**Shot 2: MM:SS:**\n"
            "[repeat format for each shot]\n\n"
            
            "Do NOT add any other text, explanations, or sections. Output ONLY the structured data in this exact format."
        )

        resp = client.models.generate_content(
            model=model_name,
            contents=[
                {"role": "user", "parts": [{"text": json.dumps(raw)}]},
            ],
            config={
                "system_instruction": system,
                "temperature": temperature,
                "max_output_tokens": max_output_tokens,
            },
        )

        text = (getattr(resp, "text", None) or "").strip()
        if not text:
            raise RuntimeError("Gemini returned empty response")

        return text

    except Exception as e:
        raise RuntimeError(f"Gemini API call failed: {e}")




def save_summary_text(video_or_json: Path, summary: str) -> Path:
    """Save summary next to results JSON under results/drill/ with _summary.txt suffix."""
    stem = video_or_json.stem
    out_dir = Path("results/drill")
    out_dir.mkdir(parents=True, exist_ok=True)
    out_path = out_dir / f"{stem}_summary.txt"
    out_path.write_text(summary)
    return out_path


def main() -> None:
    parser = argparse.ArgumentParser(description="Data Summary Agent - Interprets pose_extraction_shooting_drills.py JSON output")
    parser.add_argument("json_path", help="Path to drill feedback JSON file")
    parser.add_argument("--model", default="gemini-2.5-flash-lite", help="Gemini model name")
    parser.add_argument("--temperature", type=float, default=0.1)
    parser.add_argument("--max_tokens", type=int, default=1024)
    parser.add_argument("--local", action="store_true", help="Force local formatting (skip Gemini)")
    args = parser.parse_args()

    source_path = Path(args.json_path)
    if not source_path.exists():
        raise FileNotFoundError(f"JSON not found: {source_path}")
    
    result = load_feedback_json(source_path)

    # Use local formatting if requested, otherwise try Gemini with fallback
    if args.local:
        summary = format_shot_summary_locally(result)
    else:
        try:
            summary = generate_summary_with_gemini(
                result,
                model_name=args.model,
                temperature=args.temperature,
                max_output_tokens=args.max_tokens,
            )
        except Exception as e:
            print(f"Gemini formatting failed ({e}), using local formatting")
            summary = format_shot_summary_locally(result)

    out_path = save_summary_text(source_path, summary)
    print(summary)
    print(f"\nSaved: {out_path}")


if __name__ == "__main__":
    main()


