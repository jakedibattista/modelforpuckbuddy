#!/usr/bin/env python3
"""Data Summary Agent (Gemini Flash Lite + local heuristics)

This agent:
- Interprets the JSON output from shooting_drill_feedback.py
- Produces a short, data-focused summary using deterministic heuristics
- Optionally sends the draft to a lightweight LLM (Gemini 2.5 Flash Lite)
  for tone polishing, with strict instructions and low token limits

Usage:
  python data_summary_agent.py results/drill/foo_drill_feedback.json

Environment:
  GOOGLE_API_KEY (optional). If missing or model fails, falls back to local summary.
"""

from __future__ import annotations

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from utils.config import load_env
from utils.io import load_json_file
load_env()

# Unified Google GenAI client import
try:
    from google import genai  # type: ignore
    GENAI_AVAILABLE = True
except Exception:
    GENAI_AVAILABLE = False



def load_feedback_json(json_path: Path) -> Dict[str, Any]:
    """Load a drill feedback JSON file using shared utility.

    Args:
        json_path: Path to the JSON file generated by shooting_drill_feedback.py

    Returns:
        Parsed JSON as a Python dict.
    """
    return load_json_file(json_path)


def format_timestamp(time_sec: float) -> str:
    """Format time in seconds to MM:SS format.
    
    Args:
        time_sec: Time in seconds (can have decimal places)
        
    Returns:
        Formatted time string in MM:SS format
    """
    if time_sec == "N/A" or time_sec is None:
        return "N/A"
    
    try:
        total_seconds = int(round(float(time_sec)))
        minutes = total_seconds // 60
        seconds = total_seconds % 60
        return f"{minutes:02d}:{seconds:02d}"
    except (ValueError, TypeError):
        return "N/A"


def validate_shot_data(shot: Dict[str, Any]) -> Dict[str, Any]:
    """Validate shot data and extract all relevant metrics.

    Args:
        shot: One shot dict from the feedback JSON

    Returns:
        A dict with validated fields, N/A for missing data.
    """
    result = {}
    
    # Basic timing and metrics
    result["time"] = shot.get("shot_time_sec", "N/A")
    result["time_formatted"] = format_timestamp(result["time"])
    
    # Front knee angle (use enhanced data if available, fallback to legacy)
    front_knee = None
    if shot.get("lower_body_triangle") and shot["lower_body_triangle"].get("front_knee_bend_deg") is not None:
        front_knee = shot["lower_body_triangle"]["front_knee_bend_deg"]
    else:
        front_knee = shot.get("knee_bend_min_deg")
    result["front_knee_angle"] = f"{front_knee:.0f}°" if front_knee is not None else "not tracked"
    
    # Hip drive
    hip_drive = shot.get("hip_drive", 0.0)
    hip_drive_good = shot.get("hip_drive_good", False)
    if hip_drive is not None and hip_drive != "N/A":
        result["hip_drive"] = f"{hip_drive:.3f} ({'good' if hip_drive_good else 'needs work'})"
    else:
        result["hip_drive"] = "not tracked"
    
    # Wrist steadiness (control smoothness)
    control = shot.get("control_smoothness")
    if control is not None and control != "N/A":
        if control >= 0.6:
            label = "smooth"
        elif control <= 0.3:
            label = "jerky"
        else:
            label = "mixed"
        result["wrist_steadiness"] = label
    else:
        result["wrist_steadiness"] = "not tracked"
    
    # Head position (from enhanced metrics)
    head_pos = shot.get("head_position", {})
    if head_pos and any(v is not None for v in head_pos.values()):
        # Average the available head metrics
        head_values = [v for v in head_pos.values() if v is not None]
        if head_values:
            avg_head = sum(head_values) / len(head_values)
            if avg_head >= 0.8:
                result["head_position"] = "excellent"
            elif avg_head >= 0.6:
                result["head_position"] = "good"
            else:
                result["head_position"] = "needs work"
        else:
            result["head_position"] = "not tracked"
    else:
        result["head_position"] = "not tracked"
    
    # Back leg angle
    back_leg = None
    if shot.get("lower_body_triangle") and shot["lower_body_triangle"].get("back_leg_extension_deg") is not None:
        back_leg = shot["lower_body_triangle"]["back_leg_extension_deg"]
    
    if back_leg is not None:
        result["back_leg_angle"] = f"{back_leg:.0f}°"
        if back_leg < 150:
            result["back_leg_angle"] += " (too bent)"
    else:
        result["back_leg_angle"] = "not tracked"
    
    return result


def format_shot_summary_locally(raw: Dict[str, Any]) -> str:
    """Generate formatted summary using local processing.
    
    Args:
        raw: Full analysis result dictionary
        
    Returns:
        Formatted summary string in the new structured format
    """
    shots = raw.get("shots", [])
    if not shots:
        return "No shots detected in video"
    
    # Format timestamp header
    timestamps = []
    for shot in shots:
        time_sec = shot.get("shot_time_sec")
        if time_sec is not None:
            timestamps.append(format_timestamp(time_sec))
        else:
            timestamps.append("N/A")
    
    timestamp_line = f"Shots detected at timestamps: {', '.join(timestamps)}"
    
    # Format each shot
    shot_lines = []
    for i, shot in enumerate(shots, 1):
        validated = validate_shot_data(shot)
        
        shot_block = f"Shot {i}: time {validated['time_formatted']}:\n"
        shot_block += f"front knee angle: {validated['front_knee_angle']}\n"
        shot_block += f"hip drive: {validated['hip_drive']}\n"
        shot_block += f"wrist steadiness: {validated['wrist_steadiness']}\n"
        shot_block += f"head position: {validated['head_position']}\n"
        shot_block += f"back leg angle: {validated['back_leg_angle']}"
        
        shot_lines.append(shot_block)
    
    return timestamp_line + "\n\n" + "\n\n".join(shot_lines)


def generate_summary_with_gemini(
    raw: Dict[str, Any],
    model_name: str = "gemini-2.5-flash-lite",
    temperature: float = 0.1,
    max_output_tokens: int = 512,
) -> str:
    """Generate data-focused summary using Gemini with strict instructions.

    Returns polished text, or raises an error if fails.
    """
    if not GENAI_AVAILABLE:
        raise RuntimeError("google genai client not available. Install with: pip install google-genai")

    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        raise RuntimeError("GOOGLE_API_KEY environment variable not set")

    try:
        client = genai.Client(api_key=api_key)
        system = (
            "You are a data analysis system. Format the shooting drill JSON data into the EXACT structured format specified below. "
            "CRITICAL: Follow the format precisely with no deviations.\n\n"
            
            "Time formatting: Convert all shot_time_sec values to MM:SS format (e.g., 8.2 seconds becomes 00:08).\n"
            
            "Metrics interpretation:\n"
            "- Front knee angle: Use front_knee_bend_deg from lower_body_triangle if available, else knee_bend_min_deg\n"
            "- Hip drive: Format as 'X.XXX (good/needs work)' based on hip_drive value and hip_drive_good boolean\n"
            "- Wrist steadiness: Convert control_smoothness to labels: ≥0.6='smooth', ≤0.3='jerky', else='mixed'\n"
            "- Head position: Average head_position metrics (forward_lean, eye_level, target_facing): ≥0.8='excellent', ≥0.6='good', else='needs work'\n"
            "- Back leg angle: Use back_leg_extension_deg from lower_body_triangle, add '(too bent)' if <150°\n"
            "- For any missing data, use 'not tracked'\n\n"
            
            "EXACT OUTPUT FORMAT:\n"
            "Shots detected at timestamps: MM:SS, MM:SS, MM:SS\n\n"
            "Shot 1: time MM:SS:\n"
            "front knee angle: XXX°\n"
            "hip drive: X.XXX (good/needs work)\n"
            "wrist steadiness: smooth/jerky/mixed\n"
            "head position: excellent/good/needs work\n"
            "back leg angle: XXX°\n\n"
            "Shot 2: time MM:SS:\n"
            "[repeat format for each shot]\n\n"
            
            "Do NOT add any other text, explanations, or sections. Output ONLY the structured data in this exact format."
        )

        resp = client.models.generate_content(
            model=model_name,
            contents=[
                {"role": "user", "parts": [{"text": json.dumps(raw)}]},
            ],
            config={
                "system_instruction": system,
                "temperature": temperature,
                "max_output_tokens": max_output_tokens,
            },
        )

        text = (getattr(resp, "text", None) or "").strip()
        if not text:
            raise RuntimeError("Gemini returned empty response")

        return text

    except Exception as e:
        raise RuntimeError(f"Gemini API call failed: {e}")




def save_summary_text(video_or_json: Path, summary: str) -> Path:
    """Save summary next to results JSON under results/drill/ with _summary.txt suffix."""
    stem = video_or_json.stem
    out_dir = Path("results/drill")
    out_dir.mkdir(parents=True, exist_ok=True)
    out_path = out_dir / f"{stem}_summary.txt"
    out_path.write_text(summary)
    return out_path


def main() -> None:
    parser = argparse.ArgumentParser(description="Data Summary Agent - Interprets shooting_drill_feedback.py JSON output")
    parser.add_argument("json_path", help="Path to drill feedback JSON file")
    parser.add_argument("--model", default="gemini-2.5-flash-lite", help="Gemini model name")
    parser.add_argument("--temperature", type=float, default=0.1)
    parser.add_argument("--max_tokens", type=int, default=512)
    parser.add_argument("--local", action="store_true", help="Force local formatting (skip Gemini)")
    args = parser.parse_args()

    source_path = Path(args.json_path)
    if not source_path.exists():
        raise FileNotFoundError(f"JSON not found: {source_path}")
    
    result = load_feedback_json(source_path)

    # Use local formatting if requested, otherwise try Gemini with fallback
    if args.local:
        summary = format_shot_summary_locally(result)
    else:
        try:
            summary = generate_summary_with_gemini(
                result,
                model_name=args.model,
                temperature=args.temperature,
                max_output_tokens=args.max_tokens,
            )
        except Exception as e:
            print(f"Gemini formatting failed ({e}), using local formatting")
            summary = format_shot_summary_locally(result)

    out_path = save_summary_text(source_path, summary)
    print(summary)
    print(f"\nSaved: {out_path}")


if __name__ == "__main__":
    main()


