#!/usr/bin/env python3
"""Data Summary Agent (Gemini Flash Lite + local heuristics)

This agent:
- Interprets the JSON output from pose_extraction_shooting_drills.py
- Produces a short, data-focused summary using deterministic heuristics
- Optionally sends the draft to a lightweight LLM (Gemini 2.5 Flash Lite)
  for tone polishing, with strict instructions and low token limits

Usage:
  python data_summary_agent.py results/drill/foo_drill_feedback.json

Environment:
  GOOGLE_API_KEY (optional). If missing or model fails, falls back to local summary.
"""

from __future__ import annotations

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from utils.config import load_env
from utils.io import load_json_file
load_env()

# Unified Google GenAI client import
try:
    from google import genai  # type: ignore
    GENAI_AVAILABLE = True
except Exception:
    GENAI_AVAILABLE = False



def load_feedback_json(json_path: Path) -> Dict[str, Any]:
    """Load a drill feedback JSON file using shared utility.

    Args:
        json_path: Path to the JSON file generated by pose_extraction_shooting_drills.py

    Returns:
        Parsed JSON as a Python dict.
    """
    return load_json_file(json_path)


def format_timestamp(time_sec: float) -> str:
    """Format time in seconds to MM:SS format.
    
    Args:
        time_sec: Time in seconds (can have decimal places)
        
    Returns:
        Formatted time string in MM:SS format
    """
    if time_sec == "N/A" or time_sec is None:
        return "N/A"
    
    try:
        total_seconds = int(round(float(time_sec)))
        minutes = total_seconds // 60
        seconds = total_seconds % 60
        return f"{minutes:02d}:{seconds:02d}"
    except (ValueError, TypeError):
        return "N/A"


def validate_shot_data(shot: Dict[str, Any]) -> Dict[str, Any]:
    """Validate shot data and extract all relevant metrics.

    Args:
        shot: One shot dict from the feedback JSON

    Returns:
        A dict with validated fields, N/A for missing data.
    """
    result = {}
    
    # Basic timing and metrics
    result["time"] = shot.get("shot_time_sec", "N/A")
    result["time_formatted"] = format_timestamp(result["time"])
    
    # Front knee angle (use enhanced data if available, fallback to legacy)
    front_knee = None
    if shot.get("lower_body_triangle") and shot["lower_body_triangle"].get("front_knee_bend_deg") is not None:
        front_knee = shot["lower_body_triangle"]["front_knee_bend_deg"]
    else:
        front_knee = shot.get("knee_bend_min_deg")
    result["front_knee_angle"] = f"{front_knee:.0f}°" if front_knee is not None else "not tracked"
    
    # Hip drive - include peak speed for context (more informative than just score)
    hip_analysis = shot.get("hip_drive_analysis", {})
    if hip_analysis and hip_analysis.get("hip_drive_score") is not None:
        score = hip_analysis["hip_drive_score"]
        category = hip_analysis.get("hip_drive_category", "unknown")
        peak_speed = hip_analysis.get("peak_forward_speed")
        
        if peak_speed is not None:
            # Include speed context - helps users understand what "excellent" means
            result["hip_drive"] = f"{category} ({score:.0f}/100, {peak_speed:.1f} speed)"
        else:
            result["hip_drive"] = f"{category} ({score:.0f}/100)"
    else:
        # Fallback to legacy hip drive metrics
        hip_drive = shot.get("hip_drive", 0.0)
        hip_drive_good = shot.get("hip_drive_good", False)
        if hip_drive is not None and hip_drive != "N/A":
            result["hip_drive"] = f"{hip_drive:.3f} ({'good' if hip_drive_good else 'needs work'})"
        else:
            result["hip_drive"] = "not tracked"
    
    # Wrist performance - prefer follow-through extension over setup control (more reliable)
    wrist_extension = shot.get("wrist_extension", {})
    if wrist_extension and wrist_extension.get("follow_through_score") is not None:
        follow_score = wrist_extension["follow_through_score"]
        left_score = wrist_extension.get("left_wrist_extension_score")
        right_score = wrist_extension.get("right_wrist_extension_score")
        
        if follow_score >= 85.0:
            category = "excellent extension"
        elif follow_score >= 70.0:
            category = "good extension"
        elif follow_score >= 50.0:
            category = "fair extension"
        else:
            category = "poor extension"
        
        # Show L/R breakdown if significantly different
        if left_score is not None and right_score is not None and abs(left_score - right_score) > 15.0:
            result["wrist_performance"] = f"{category} ({follow_score:.0f}/100, L:{left_score:.0f} R:{right_score:.0f})"
        else:
            result["wrist_performance"] = f"{category} ({follow_score:.0f}/100)"
    else:
        # Fallback to setup control if extension not available
        wrist_control = shot.get("wrist_control", {})
        if wrist_control and wrist_control.get("setup_control_score") is not None and wrist_control["setup_control_score"] > 0:
            score = wrist_control["setup_control_score"]
            category = wrist_control.get("setup_control_category", "unknown")
            result["wrist_performance"] = f"{category} setup ({score:.0f}/100)"
        else:
            result["wrist_performance"] = "not tracked"
    
    # Head position - break down into intuitive components
    head_pos = shot.get("head_position", {})
    if head_pos and any(v is not None for v in head_pos.values()):
        head_up = head_pos.get("head_up_score")
        eyes_forward = head_pos.get("eyes_forward_score")
        
        if head_up is not None and eyes_forward is not None:
            # Show breakdown since these measure different things
            head_label = "excellent" if head_up >= 80 else ("good" if head_up >= 60 else "low")
            eyes_label = "locked" if eyes_forward >= 80 else ("focused" if eyes_forward >= 60 else "wandering")
            
            result["head_position"] = f"head {head_label} ({head_up:.0f}), eyes {eyes_label} ({eyes_forward:.0f})"
        elif head_up is not None:
            head_label = "excellent" if head_up >= 80 else ("good" if head_up >= 60 else "low")
            result["head_position"] = f"head {head_label} ({head_up:.0f})"
        elif eyes_forward is not None:
            eyes_label = "locked" if eyes_forward >= 80 else ("focused" if eyes_forward >= 60 else "wandering")
            result["head_position"] = f"eyes {eyes_label} ({eyes_forward:.0f})"
        else:
            result["head_position"] = "not tracked"
    else:
        result["head_position"] = "not tracked"
    
    # Back leg angle
    back_leg = None
    if shot.get("lower_body_triangle") and shot["lower_body_triangle"].get("back_leg_extension_deg") is not None:
        back_leg = shot["lower_body_triangle"]["back_leg_extension_deg"]
    
    if back_leg is not None:
        result["back_leg_angle"] = f"{back_leg:.0f}°"
        if back_leg < 150:
            result["back_leg_angle"] += " (too bent)"
    else:
        result["back_leg_angle"] = "not tracked"
    
    return result


def format_shot_summary_locally(raw: Dict[str, Any]) -> str:
    """Generate formatted summary using local processing.
    
    Args:
        raw: Full analysis result dictionary
        
    Returns:
        Formatted summary string in the new structured format
    """
    shots = raw.get("shots", [])
    if not shots:
        return "No shots detected in video"
    
    # Format timestamp header
    timestamps = []
    for shot in shots:
        time_sec = shot.get("shot_time_sec")
        if time_sec is not None:
            timestamps.append(format_timestamp(time_sec))
        else:
            timestamps.append("N/A")
    
    timestamp_line = f"**Shots detected at timestamps:** {', '.join(timestamps)}"
    
    # Format each shot
    shot_lines = []
    for i, shot in enumerate(shots, 1):
        validated = validate_shot_data(shot)
        
        shot_block = f"**Shot {i}: {validated['time_formatted']}:**\n"
        shot_block += f"**head position:** {validated['head_position']}\n"
        shot_block += f"**wrist performance:** {validated['wrist_performance']}\n"
        shot_block += f"**hip drive:** {validated['hip_drive']}\n"
        shot_block += f"**front knee angle:** {validated['front_knee_angle']}\n"
        shot_block += f"**back leg angle:** {validated['back_leg_angle']}"
        
        shot_lines.append(shot_block)
    
    return timestamp_line + "\n\n" + "\n\n".join(shot_lines)


def generate_summary_with_gemini(
    raw: Dict[str, Any],
    model_name: str = "gemini-2.5-flash-lite",
    temperature: float = 0.1,
    max_output_tokens: int = 1024,
) -> str:
    """Generate data-focused summary using Gemini with strict instructions.

    Returns polished text, or raises an error if fails.
    """
    if not GENAI_AVAILABLE:
        raise RuntimeError("google genai client not available. Install with: pip install google-genai")

    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        raise RuntimeError("GOOGLE_API_KEY environment variable not set")

    try:
        client = genai.Client(api_key=api_key)
        system = (
            "You are a data analysis system. Format the shooting drill JSON data into the EXACT structured format specified below. "
            "CRITICAL: Follow the format precisely with no deviations.\n\n"
            
            "Time formatting: Convert all shot_time_sec values to MM:SS format (e.g., 8.2 seconds becomes 00:08).\n"
            
            "Metrics interpretation:\n"
            "- Head position: Break down head_up_score and eyes_forward_score separately with intuitive labels\n"
            "- Wrist performance: Prefer wrist_extension.follow_through_score over setup_control (more reliable)\n"
            "- Hip drive: Include hip_drive_analysis.peak_forward_speed for context alongside category\n"
            "- Front knee angle: Use front_knee_bend_deg from lower_body_triangle if available, else knee_bend_min_deg\n"
            "- Back leg angle: Use back_leg_extension_deg from lower_body_triangle, add '(too bent)' if <150°\n"
            "- For any missing data, use 'not tracked'\n\n"
            
            "EXACT OUTPUT FORMAT:\n"
            "**Shots detected at timestamps:** MM:SS, MM:SS, MM:SS\n\n"
            "**Shot 1: MM:SS:**\n"
            "**head position:** head excellent/good/low (XX), eyes locked/focused/wandering (XX)\n"
            "**wrist performance:** excellent/good/fair extension (XX/100) or excellent/good/fair extension (XX/100, L:XX R:XX)\n"
            "**hip drive:** excellent/good/weak (XX/100, XX.X speed)\n"
            "**front knee angle:** XXX°\n"
            "**back leg angle:** XXX°\n\n"
            "**Shot 2: MM:SS:**\n"
            "[repeat format for each shot]\n\n"
            
            "Do NOT add any other text, explanations, or sections. Output ONLY the structured data in this exact format."
        )

        resp = client.models.generate_content(
            model=model_name,
            contents=[
                {"role": "user", "parts": [{"text": json.dumps(raw)}]},
            ],
            config={
                "system_instruction": system,
                "temperature": temperature,
                "max_output_tokens": max_output_tokens,
            },
        )

        text = (getattr(resp, "text", None) or "").strip()
        if not text:
            raise RuntimeError("Gemini returned empty response")

        return text

    except Exception as e:
        raise RuntimeError(f"Gemini API call failed: {e}")




def save_summary_text(video_or_json: Path, summary: str) -> Path:
    """Save summary next to results JSON under results/drill/ with _summary.txt suffix."""
    stem = video_or_json.stem
    out_dir = Path("results/drill")
    out_dir.mkdir(parents=True, exist_ok=True)
    out_path = out_dir / f"{stem}_summary.txt"
    out_path.write_text(summary)
    return out_path


def main() -> None:
    parser = argparse.ArgumentParser(description="Data Summary Agent - Interprets pose_extraction_shooting_drills.py JSON output")
    parser.add_argument("json_path", help="Path to drill feedback JSON file")
    parser.add_argument("--model", default="gemini-2.5-flash-lite", help="Gemini model name")
    parser.add_argument("--temperature", type=float, default=0.1)
    parser.add_argument("--max_tokens", type=int, default=1024)
    parser.add_argument("--local", action="store_true", help="Force local formatting (skip Gemini)")
    args = parser.parse_args()

    source_path = Path(args.json_path)
    if not source_path.exists():
        raise FileNotFoundError(f"JSON not found: {source_path}")
    
    result = load_feedback_json(source_path)

    # Use local formatting if requested, otherwise try Gemini with fallback
    if args.local:
        summary = format_shot_summary_locally(result)
    else:
        try:
            summary = generate_summary_with_gemini(
                result,
                model_name=args.model,
                temperature=args.temperature,
                max_output_tokens=args.max_tokens,
            )
        except Exception as e:
            print(f"Gemini formatting failed ({e}), using local formatting")
            summary = format_shot_summary_locally(result)

    out_path = save_summary_text(source_path, summary)
    print(summary)
    print(f"\nSaved: {out_path}")


if __name__ == "__main__":
    main()


