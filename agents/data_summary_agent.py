#!/usr/bin/env python3
"""Data Summary Agent - Individual Metric Analysis and Age-Adjusted Scoring

This agent processes hockey shooting analysis data and provides detailed breakdowns
of individual biomechanical metrics with age-appropriate scoring adjustments.

Key Features:
- Individual metric scoring (Power: knee, hip, drive, transfer, torso)
- Individual metric scoring (Form: left/right wrist, head position, stability)
- Age-adjusted scoring with boost curves (7-9: 30%, 10-12: 20%, 13-16: 10%, 17+: 0%)
- Bullet-point formatted output with consistent categories
- No external AI dependencies - pure deterministic Python logic

Usage:
  python data_summary_agent.py results/drill/foo_drill_feedback.json

Output Format:
- Age group information with applied boost percentage
- Individual metric scores with age-adjusted values
- Categories based on adjusted scores for consistency
- Clean bullet-point formatting for readability
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Any, Dict, Tuple

from utils.config import load_env
from utils.io import load_json_file
load_env()

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def load_feedback_json(json_path: Path) -> Dict[str, Any]:
    """Load a drill feedback JSON file using shared utility.

    Args:
        json_path: Path to the JSON file generated by pose_extraction_shooting_drills.py

    Returns:
        Parsed JSON as a Python dict.
    """
    return load_json_file(json_path)


def format_timestamp(time_sec: float) -> str:
    """Format time in seconds to MM:SS format.
    
    Args:
        time_sec: Time in seconds (can have decimal places)
        
    Returns:
        Formatted time string in MM:SS format
    """
    if time_sec == "N/A" or time_sec is None:
        return "N/A"
    
    try:
        total_seconds = int(round(float(time_sec)))
        minutes = total_seconds // 60
        seconds = total_seconds % 60
        return f"{minutes:02d}:{seconds:02d}"
    except (ValueError, TypeError):
        return "N/A"


# ============================================================================
# INDIVIDUAL METRIC SCORING FUNCTIONS
# ============================================================================

def score_front_knee_bend(angle_deg: float) -> Tuple[int, str]:
    """Score front knee bend on 1-10 scale for high school/college level.
    
    Args:
        angle_deg: Knee bend angle in degrees
        
    Returns:
        Tuple of (score 1-10, category)
    """
    # Adjusted for high school/college level expectations
    if angle_deg <= 110:
        return (10, "excellent")
    elif angle_deg <= 120:
        return (9, "very good")
    elif angle_deg <= 130:
        return (8, "good")
    elif angle_deg <= 140:
        return (7, "fair")
    elif angle_deg <= 150:
        return (6, "poor")
    elif angle_deg <= 160:
        return (4, "very poor")
    else:
        return (2, "terrible")

def score_hip_rotation_power(rotation_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score hip rotation power on 1-10 scale.
    
    Args:
        rotation_data: hip_rotation_power dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    max_speed = rotation_data.get("max_rotation_speed", 0.0)
    angle_change = rotation_data.get("rotation_angle_change", 0.0)
    
    # Combine speed and angle change for overall power score
    power_score = (max_speed * 0.6) + (angle_change * 0.4)
    
    if power_score >= 60:
        return (10, "explosive")
    elif power_score >= 45:
        return (9, "excellent")
    elif power_score >= 35:
        return (8, "very good")
    elif power_score >= 25:
        return (7, "good")
    elif power_score >= 15:
        return (6, "fair")
    elif power_score >= 10:
        return (5, "poor")
    elif power_score >= 5:
        return (3, "very poor")
    else:
        return (1, "none")

def score_weight_transfer(transfer_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score weight transfer on 1-10 scale.
    
    Args:
        transfer_data: weight_transfer dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    max_speed = transfer_data.get("max_transfer_speed", 0.0)
    distance = transfer_data.get("weight_shift_distance", 0.0)
    
    # Combine speed and distance for transfer quality
    # Fixed: Scale values properly
    transfer_score = (max_speed * 1000) + (distance * 1000)  # Scale up small values
    
    # More realistic thresholds based on typical values (0-100 range after scaling)
    if transfer_score >= 50:
        return (10, "excellent")
    elif transfer_score >= 30:
        return (9, "very good")
    elif transfer_score >= 20:
        return (8, "good")
    elif transfer_score >= 15:
        return (7, "fair")
    elif transfer_score >= 10:
        return (6, "poor")
    elif transfer_score >= 5:
        return (4, "very poor")
    else:
        return (2, "minimal")

def score_torso_rotation(rotation_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score torso rotation on 1-10 scale.
    
    Args:
        rotation_data: torso_rotation dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    shoulder_rot = rotation_data.get("shoulder_rotation", 0.0)
    hip_rot = rotation_data.get("hip_rotation", 0.0)
    sync = rotation_data.get("rotation_sync", 0.0)
    
    # Score based on rotation amount and synchronization
    rotation_amount = max(shoulder_rot, hip_rot)
    sync_bonus = sync * 2  # Sync is 0-1, so multiply by 2 for bonus
    
    total_score = rotation_amount + sync_bonus
    
    if total_score >= 50:
        return (10, "excellent")
    elif total_score >= 40:
        return (9, "very good")
    elif total_score >= 30:
        return (8, "good")
    elif total_score >= 20:
        return (7, "fair")
    elif total_score >= 15:
        return (6, "poor")
    elif total_score >= 10:
        return (4, "very poor")
    else:
        return (2, "minimal")

def score_back_leg_drive(drive_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score back leg drive on 1-10 scale.
    
    Args:
        drive_data: back_leg_drive dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    extension_change = drive_data.get("extension_change", 0.0)
    extension_speed = drive_data.get("extension_speed", 0.0)
    consistency = drive_data.get("drive_consistency", 0.0)
    
    # Combine extension change, speed, and consistency
    drive_score = (extension_change * 0.4) + (extension_speed * 0.4) + (consistency * 20)
    
    if drive_score >= 25:
        return (10, "excellent")
    elif drive_score >= 20:
        return (9, "very good")
    elif drive_score >= 15:
        return (8, "good")
    elif drive_score >= 10:
        return (7, "fair")
    elif drive_score >= 7:
        return (6, "poor")
    elif drive_score >= 4:
        return (4, "very poor")
    else:
        return (2, "minimal")

def score_wrist_extension(extension_data: Dict[str, Any]) -> Tuple[int, str, Dict[str, Any]]:
    """Score wrist extension on 1-10 scale, showing left and right separately.
    
    Args:
        extension_data: wrist_extension dict from shot
        
    Returns:
        Tuple of (overall_score, category, wrist_breakdown)
    """
    follow_through = extension_data.get("follow_through_score")
    left_score = extension_data.get("left_wrist_extension_score")
    right_score = extension_data.get("right_wrist_extension_score")
    
    # Score each wrist individually
    left_wrist_score = 0
    right_wrist_score = 0
    left_tracked = False
    right_tracked = False
    
    # Score left wrist
    if left_score is not None and left_score > 30:
        left_wrist_score = _score_wrist_individual(left_score)
        left_tracked = True
    
    # Score right wrist  
    if right_score is not None and right_score > 30:
        right_wrist_score = _score_wrist_individual(right_score)
        right_tracked = True
    
    # Use follow-through as backup if available
    if follow_through is not None and follow_through > 30 and not left_tracked and not right_tracked:
        overall_score = _score_wrist_individual(follow_through)
        category = _get_wrist_category(overall_score)
        return (overall_score, category, {
            "left_wrist": {"score": 0, "tracked": False},
            "right_wrist": {"score": 0, "tracked": False},
            "follow_through": {"score": overall_score, "tracked": True}
        })
    
    # If no valid data, mark as not tracked
    if not left_tracked and not right_tracked:
        return (0, "not tracked", {
            "left_wrist": {"score": 0, "tracked": False},
            "right_wrist": {"score": 0, "tracked": False},
            "follow_through": {"score": 0, "tracked": False}
        })
    
    # Calculate overall score as average of tracked wrists
    if left_tracked and right_tracked:
        overall_score = (left_wrist_score + right_wrist_score) / 2
    elif left_tracked:
        overall_score = left_wrist_score
    else:
        overall_score = right_wrist_score
    
    category = _get_wrist_category(overall_score)
    
    return (overall_score, category, {
        "left_wrist": {"score": left_wrist_score, "tracked": left_tracked},
        "right_wrist": {"score": right_wrist_score, "tracked": right_tracked},
        "follow_through": {"score": follow_through if follow_through and follow_through > 30 else 0, "tracked": follow_through and follow_through > 30}
    })

def _score_wrist_individual(score: float) -> int:
    """Score individual wrist extension."""
    if score >= 90:
        return 10
    elif score >= 80:
        return 9
    elif score >= 70:
        return 8
    elif score >= 60:
        return 7
    elif score >= 50:
        return 6
    elif score >= 40:
        return 4
    else:
        return 2

# ============================================================================
# CATEGORY HELPER FUNCTIONS
# ============================================================================

def _get_wrist_category(score: float) -> str:
    """Get wrist extension category."""
    if score >= 9:
        return "excellent"
    elif score >= 8:
        return "very good"
    elif score >= 7:
        return "good"
    elif score >= 6:
        return "fair"
    elif score >= 4:
        return "poor"
    else:
        return "minimal"

def _get_knee_category(score: float) -> str:
    """Get knee bend category."""
    if score >= 9:
        return "excellent"
    elif score >= 8:
        return "very good"
    elif score >= 7:
        return "good"
    elif score >= 6:
        return "fair"
    elif score >= 4:
        return "poor"
    else:
        return "minimal"

def _get_hip_category(score: float) -> str:
    """Get hip rotation category."""
    if score >= 9:
        return "excellent"
    elif score >= 8:
        return "very good"
    elif score >= 7:
        return "good"
    elif score >= 6:
        return "fair"
    elif score >= 4:
        return "poor"
    else:
        return "minimal"

def _get_drive_category(score: float) -> str:
    """Get back leg drive category."""
    if score >= 9:
        return "excellent"
    elif score >= 8:
        return "very good"
    elif score >= 7:
        return "good"
    elif score >= 6:
        return "fair"
    elif score >= 4:
        return "poor"
    else:
        return "minimal"

def _get_transfer_category(score: float) -> str:
    """Get weight transfer category."""
    if score >= 9:
        return "excellent"
    elif score >= 8:
        return "very good"
    elif score >= 7:
        return "good"
    elif score >= 6:
        return "fair"
    elif score >= 4:
        return "poor"
    else:
        return "minimal"

def _get_torso_category(score: float) -> str:
    """Get torso rotation category."""
    if score >= 9:
        return "excellent"
    elif score >= 8:
        return "very good"
    elif score >= 7:
        return "good"
    elif score >= 6:
        return "fair"
    elif score >= 4:
        return "poor"
    else:
        return "minimal"

def _get_head_category(score: float) -> str:
    """Get head position category."""
    if score >= 9:
        return "excellent"
    elif score >= 8:
        return "very good"
    elif score >= 7:
        return "good"
    elif score >= 6:
        return "fair"
    elif score >= 4:
        return "poor"
    else:
        return "minimal"

def _get_stability_category(score: float) -> str:
    """Get body stability category."""
    if score >= 9:
        return "excellent"
    elif score >= 8:
        return "very good"
    elif score >= 7:
        return "good"
    elif score >= 6:
        return "fair"
    elif score >= 4:
        return "poor"
    else:
        return "minimal"

def score_head_position(head_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score head position on 1-10 scale.
    
    Args:
        head_data: head_position dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    head_up = head_data.get("head_up_score", 0.0)
    eyes_forward = head_data.get("eyes_forward_score", 0.0)
    
    # Check if we have valid data
    if head_up is None and eyes_forward is None:
        return (0, "not tracked")
    
    # Average head up and eyes forward scores, or use available data
    if head_up is not None and eyes_forward is not None:
        score = (head_up + eyes_forward) / 2
    elif head_up is not None:
        score = head_up
    else:
        score = eyes_forward
    
    # Adjusted thresholds for head position to match power metric strictness
    if score >= 90:
        return (10, "excellent")
    elif score >= 80:
        return (9, "very good")
    elif score >= 70:
        return (8, "good")
    elif score >= 60:
        return (7, "fair")
    elif score >= 50:
        return (6, "poor")
    elif score >= 40:
        return (4, "very poor")
    else:
        return (2, "minimal")

def score_body_stability(stability_data: Dict[str, Any]) -> Tuple[int, str]:
    """Score body stability on 1-10 scale.
    
    Args:
        stability_data: body_stability dict from shot
        
    Returns:
        Tuple of (score 1-10, category)
    """
    stability_score = stability_data.get("stability_score", 0.0)
    consistency = stability_data.get("movement_consistency", 0.0)
    
    # Use stability score as primary, consistency as secondary
    # Convert to 0-100 scale to match other metrics, then apply stricter thresholds
    score = ((stability_score * 0.7) + (consistency * 0.3)) * 100
    
    if score >= 90:
        return (10, "excellent")
    elif score >= 80:
        return (9, "very good")
    elif score >= 70:
        return (8, "good")
    elif score >= 60:
        return (7, "fair")
    elif score >= 50:
        return (6, "poor")
    elif score >= 40:
        return (4, "very poor")
    else:
        return (2, "minimal")

# ============================================================================
# METRIC CALCULATION FUNCTIONS
# ============================================================================

def calculate_power_metrics(shot: Dict[str, Any]) -> Dict[str, Any]:
    """Calculate individual power metrics from shot data.
    
    Args:
        shot: Shot data dictionary
        
    Returns:
        Dictionary of power metrics with scores and categories
    """
    power_metrics = {}
    
    # Front Knee Bend
    front_knee_angle = shot.get("front_knee_bend_deg")
    if front_knee_angle is not None:
        knee_score, knee_category = score_front_knee_bend(front_knee_angle)
        power_metrics["front_knee"] = {
            "score": knee_score,
            "category": knee_category,
            "angle": front_knee_angle
        }
    else:
        power_metrics["front_knee"] = {"score": 1, "category": "not tracked", "angle": None}
    
    # Hip Rotation Power
    hip_rotation = shot.get("hip_rotation_power", {})
    if hip_rotation:
        hip_score, hip_category = score_hip_rotation_power(hip_rotation)
        power_metrics["hip_rotation"] = {
            "score": hip_score,
            "category": hip_category,
            "data": hip_rotation
        }
    else:
        power_metrics["hip_rotation"] = {"score": 1, "category": "not tracked", "data": {}}
    
    # Back Leg Drive
    back_leg_drive = shot.get("back_leg_drive", {})
    if back_leg_drive:
        drive_score, drive_category = score_back_leg_drive(back_leg_drive)
        power_metrics["back_leg_drive"] = {
            "score": drive_score,
            "category": drive_category,
            "data": back_leg_drive
        }
    else:
        power_metrics["back_leg_drive"] = {"score": 1, "category": "not tracked", "data": {}}
    
    # Weight Transfer
    weight_transfer = shot.get("weight_transfer", {})
    if weight_transfer:
        transfer_score, transfer_category = score_weight_transfer(weight_transfer)
        power_metrics["weight_transfer"] = {
            "score": transfer_score,
            "category": transfer_category,
            "data": weight_transfer
        }
    else:
        power_metrics["weight_transfer"] = {"score": 1, "category": "not tracked", "data": {}}
    
    # Torso Rotation
    torso_rotation = shot.get("torso_rotation", {})
    if torso_rotation:
        torso_score, torso_category = score_torso_rotation(torso_rotation)
        power_metrics["torso_rotation"] = {
            "score": torso_score,
            "category": torso_category,
            "data": torso_rotation
        }
    else:
        power_metrics["torso_rotation"] = {"score": 1, "category": "not tracked", "data": {}}
    
    return power_metrics

def calculate_form_metrics(shot: Dict[str, Any]) -> Dict[str, Any]:
    """Calculate individual form metrics from shot data.
    
    Args:
        shot: Shot data dictionary
        
    Returns:
        Dictionary of form metrics with scores and categories
    """
    form_metrics = {}
    
    # Wrist Extension
    wrist_extension = shot.get("wrist_extension", {})
    if wrist_extension:
        wrist_score, wrist_category, wrist_breakdown = score_wrist_extension(wrist_extension)
        form_metrics["wrist_extension"] = {
            "score": wrist_score,
            "category": wrist_category,
            "data": wrist_extension,
            "tracked": wrist_score > 0,
            "breakdown": wrist_breakdown
        }
    else:
        form_metrics["wrist_extension"] = {
            "score": 0, 
            "category": "not tracked", 
            "data": {}, 
            "tracked": False,
            "breakdown": {
                "left_wrist": {"score": 0, "tracked": False},
                "right_wrist": {"score": 0, "tracked": False},
                "follow_through": {"score": 0, "tracked": False}
            }
        }
    
    # Head Position
    head_position = shot.get("head_position", {})
    if head_position:
        head_score, head_category = score_head_position(head_position)
        form_metrics["head_position"] = {
            "score": head_score,
            "category": head_category,
            "data": head_position,
            "tracked": head_score > 0
        }
    else:
        form_metrics["head_position"] = {"score": 0, "category": "not tracked", "data": {}, "tracked": False}
    
    # Body Stability
    body_stability = shot.get("body_stability", {})
    if body_stability:
        stability_score, stability_category = score_body_stability(body_stability)
        form_metrics["body_stability"] = {
            "score": stability_score,
            "category": stability_category,
            "data": body_stability,
            "tracked": stability_score > 0
        }
    else:
        form_metrics["body_stability"] = {"score": 0, "category": "not tracked", "data": {}, "tracked": False}
    
    return form_metrics

# ============================================================================
# AGE ADJUSTMENT FUNCTIONS
# ============================================================================

def apply_age_adjustment(score: float, age_group: str) -> float:
    """Apply age-based scoring adjustment based on predefined age groups.
    
    Args:
        score: Raw score (1-10)
        age_group: Age group from app ("7-9", "10-12", "13-16", "17+")
        
    Returns:
        Adjusted score based on age group
    """
    if age_group == "17+":
        # 17+ years: Score as-is (high school/college level) - no curve
        return score
    elif age_group == "13-16":
        # 13-16 years: Slight curve (10% boost)
        return min(10.0, score * 1.1)
    elif age_group == "10-12":
        # 10-12 years: Moderate curve (20% boost)
        return min(10.0, score * 1.2)
    elif age_group == "7-9":
        # 7-9 years: Strong curve (30% boost)
        return min(10.0, score * 1.3)
    else:
        # Default to 17+ if unknown age group
        return score

def get_age_category(age_group: str) -> str:
    """Get age category description.
    
    Args:
        age_group: Age group from app ("7-9", "10-12", "13-16", "17+")
        
    Returns:
        Age category string
    """
    if age_group == "17+":
        return "High School/College (17+)"
    elif age_group == "13-16":
        return "U16 (13-16 years)"
    elif age_group == "10-12":
        return "U12 (10-12 years)"
    elif age_group == "7-9":
        return "U10 (7-9 years)"
    else:
        return "Unknown Age Group"

# ============================================================================
# DATA VALIDATION AND PROCESSING FUNCTIONS
# ============================================================================

def validate_shot_data(shot: Dict[str, Any]) -> Dict[str, Any]:
    """Validate shot data and extract all relevant metrics.

    Args:
        shot: One shot dict from the feedback JSON

    Returns:
        A dict with validated fields, N/A for missing data.
    """
    result = {}
    
    # Basic timing and metrics
    result["time"] = shot.get("shot_time_sec", "N/A")
    result["time_formatted"] = format_timestamp(result["time"])
    
    # Get age group for adjustments (default to "17+" if not provided)
    age_group = shot.get("age_group", "17+")
    result["age_group"] = age_group
    result["age_category"] = get_age_category(age_group)
    
    # Calculate individual metrics
    result["power_metrics"] = calculate_power_metrics(shot)
    result["form_metrics"] = calculate_form_metrics(shot)
    
    return result


# ============================================================================
# OUTPUT FORMATTING FUNCTIONS
# ============================================================================

def format_shot_summary_locally(raw: Dict[str, Any]) -> str:
    """Generate formatted summary with individual metrics and age-adjusted scoring.
    
    Creates a structured output showing:
    - Shot timestamps
    - Age group with boost percentage
    - Individual power metrics (knee, hip, drive, transfer, torso)
    - Individual form metrics (left/right wrist, head, stability)
    - Age-adjusted scores with matching categories
    
    Args:
        raw: Full analysis result dictionary from pose extraction
        
    Returns:
        Formatted summary string with bullet-point structure
    """
    shots = raw.get("shots", [])
    if not shots:
        return "No shots detected in video"
    
    # Format timestamp header
    timestamps = []
    for shot in shots:
        time_sec = shot.get("shot_time_sec")
        if time_sec is not None:
            timestamps.append(format_timestamp(time_sec))
        else:
            timestamps.append("N/A")
    
    timestamp_line = f"**Shots detected at timestamps:** {', '.join(timestamps)}"
    
    # Get age group and curve info (show once at top)
    age_group = shots[0].get("age_group", "17+") if shots else "17+"
    age_category = get_age_category(age_group)
    curve_info = ""
    if age_group == "7-9":
        curve_info = " (30% boost applied)"
    elif age_group == "10-12":
        curve_info = " (20% boost applied)"
    elif age_group == "13-16":
        curve_info = " (10% boost applied)"
    elif age_group == "17+":
        curve_info = " (no curve - high school/college level)"
    
    age_line = f"**Age Group:** {age_category}{curve_info}"
    
    # Format each shot with new power vs form structure
    shot_lines = []
    for i, shot in enumerate(shots, 1):
        validated = validate_shot_data(shot)
        
        shot_block = f"**Shot {i}: {validated['time_formatted']}:**\n"
        
        # Power Metrics Breakdown
        shot_block += f"**POWER BREAKDOWN:**\n"
        power_metrics = validated['power_metrics']
        
        # Get age group for individual metric adjustments
        age_group = validated['age_group']
        
        # Front Knee Bend (15%)
        knee = power_metrics['front_knee']
        raw_knee_score = knee['score']
        adjusted_knee_score = apply_age_adjustment(raw_knee_score, age_group)
        adjusted_knee_category = _get_knee_category(adjusted_knee_score)
        shot_block += f"• Front Knee: {adjusted_knee_score:.1f}/10 ({adjusted_knee_category}, {knee['angle']:.0f}°)\n"
        
        # Hip Rotation Power (15%)
        hip = power_metrics['hip_rotation']
        raw_hip_score = hip['score']
        adjusted_hip_score = apply_age_adjustment(raw_hip_score, age_group)
        adjusted_hip_category = _get_hip_category(adjusted_hip_score)
        shot_block += f"• Hip Rotation: {adjusted_hip_score:.1f}/10 ({adjusted_hip_category})\n"
        
        # Back Leg Drive (10%)
        drive = power_metrics['back_leg_drive']
        raw_drive_score = drive['score']
        adjusted_drive_score = apply_age_adjustment(raw_drive_score, age_group)
        adjusted_drive_category = _get_drive_category(adjusted_drive_score)
        shot_block += f"• Back Leg Drive: {adjusted_drive_score:.1f}/10 ({adjusted_drive_category})\n"
        
        # Weight Transfer (15%)
        transfer = power_metrics['weight_transfer']
        raw_transfer_score = transfer['score']
        adjusted_transfer_score = apply_age_adjustment(raw_transfer_score, age_group)
        adjusted_transfer_category = _get_transfer_category(adjusted_transfer_score)
        shot_block += f"• Weight Transfer: {adjusted_transfer_score:.1f}/10 ({adjusted_transfer_category})\n"
        
        # Torso Rotation (15%)
        torso = power_metrics['torso_rotation']
        raw_torso_score = torso['score']
        adjusted_torso_score = apply_age_adjustment(raw_torso_score, age_group)
        adjusted_torso_category = _get_torso_category(adjusted_torso_score)
        shot_block += f"• Torso Rotation: {adjusted_torso_score:.1f}/10 ({adjusted_torso_category})\n\n"
        
        # Form Metrics Breakdown
        shot_block += f"**FORM BREAKDOWN:**\n"
        form_metrics = validated['form_metrics']
        
        # Left Wrist Extension (separate category)
        wrist = form_metrics['wrist_extension']
        if wrist['tracked']:
            breakdown = wrist['breakdown']
            if breakdown['left_wrist']['tracked']:
                raw_left_score = breakdown['left_wrist']['score']
                adjusted_left_score = apply_age_adjustment(raw_left_score, age_group)
                adjusted_left_category = _get_wrist_category(adjusted_left_score)
                shot_block += f"• Left Wrist Extension: {adjusted_left_score:.1f}/10 ({adjusted_left_category})\n"
            else:
                shot_block += f"• Left Wrist Extension: Not tracked (insufficient data)\n"
        else:
            shot_block += f"• Left Wrist Extension: Not tracked (insufficient data)\n"
        
        # Right Wrist Extension (separate category)
        if wrist['tracked']:
            breakdown = wrist['breakdown']
            if breakdown['right_wrist']['tracked']:
                raw_right_score = breakdown['right_wrist']['score']
                adjusted_right_score = apply_age_adjustment(raw_right_score, age_group)
                adjusted_right_category = _get_wrist_category(adjusted_right_score)
                shot_block += f"• Right Wrist Extension: {adjusted_right_score:.1f}/10 ({adjusted_right_category})\n"
            else:
                shot_block += f"• Right Wrist Extension: Not tracked (insufficient data)\n"
        else:
            shot_block += f"• Right Wrist Extension: Not tracked (insufficient data)\n"
        
        # Head Position
        head = form_metrics['head_position']
        if head['tracked']:
            raw_head_score = head['score']
            adjusted_head_score = apply_age_adjustment(raw_head_score, age_group)
            adjusted_head_category = _get_head_category(adjusted_head_score)
            shot_block += f"• Head Position: {adjusted_head_score:.1f}/10 ({adjusted_head_category})\n"
        else:
            shot_block += f"• Head Position: Not tracked (insufficient data)\n"
        
        # Body Stability
        stability = form_metrics['body_stability']
        if stability['tracked']:
            raw_stability_score = stability['score']
            adjusted_stability_score = apply_age_adjustment(raw_stability_score, age_group)
            adjusted_stability_category = _get_stability_category(adjusted_stability_score)
            shot_block += f"• Body Stability: {adjusted_stability_score:.1f}/10 ({adjusted_stability_category})"
        else:
            shot_block += f"• Body Stability: Not tracked (insufficient data)"
        
        shot_lines.append(shot_block)
    
    return timestamp_line + "\n\n" + age_line + "\n\n" + "\n\n".join(shot_lines)


# ============================================================================
# FILE I/O FUNCTIONS
# ============================================================================

def save_summary_text(video_or_json: Path, summary: str) -> Path:
    """Save summary next to results JSON under results/drill/ with _summary.txt suffix."""
    stem = video_or_json.stem
    out_dir = Path("results/drill")
    out_dir.mkdir(parents=True, exist_ok=True)
    out_path = out_dir / f"{stem}_summary.txt"
    out_path.write_text(summary)
    return out_path


# ============================================================================
# MAIN EXECUTION
# ============================================================================

def main() -> None:
    parser = argparse.ArgumentParser(description="Data Summary Agent - Interprets pose_extraction_shooting_drills.py JSON output")
    parser.add_argument("json_path", help="Path to drill feedback JSON file")
    args = parser.parse_args()

    source_path = Path(args.json_path)
    if not source_path.exists():
        raise FileNotFoundError(f"JSON not found: {source_path}")
    
    result = load_feedback_json(source_path)

    # Generate summary using local deterministic heuristics
    summary = format_shot_summary_locally(result)

    out_path = save_summary_text(source_path, summary)
    print(summary)
    print(f"\nSaved: {out_path}")


if __name__ == "__main__":
    main()


